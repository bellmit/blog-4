### mysql索引

[淘宝：Mysql二级索引定义](http://mysql.taobao.org/monthly/2020/01/01/)
[掘金：联合索引数据结构](https://juejin.cn/post/6844904073955639304)
[公众号：mysql索引那些事，好！](https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN#rd)
[简书：MySQL中char、varchar和text的区别](https://www.jianshu.com/p/cc2d99559532)
[索引那些事：包括为什么用b+树:node大小 磁盘io](https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN#rd)


#### 索引到底是什么呢?

简单说：索引就像字典的目录

正确的说：索引就是一种用于快速查找数据的数据结构，是帮助MySQL高效获取数据的排好序的数据结构。




#### 二叉树、红黑树做索引的问题：
1. 树的高度过高导致查询效率变慢。二叉太少了，一个节点大小很小，但load次数太多了。假如树的高度是50，那我要进行50次查找，50次磁盘IO那得多慢啊这开销已经很大了。这就是红黑树作为索引数据结构的弊端：树的高度过高导致查询效率变慢。

二叉树：二叉树根节点选择不合适，会退化成一个线性结构

红黑树：
那能不能做一点改造呢？我们看，红黑树的树越高遍历次数会越多，会因为树的高度影响查询效率。所以我们要解决的问题就是减少树的高度，尽量控制它的高度在一个阈值范围内。假设说不大于5，即使数据达到1千万2千万最多也就5次磁盘IO就找到了，5次磁盘IO也是可以接受的毕竟表数据这么大嘛。

怎么改造能达到这个效果呢？？？？想一下，既然树的高度不让增加，又想存很多数据。也就是说限制了纵向发展，那就横向发展呗。（身高已经增长不了了，长胖还是可以的）

对于上图的红黑树来说每个节点的子节点最多就2个，那基于横向增长的思想就让他变成3叉、4叉、5叉.....让子节点增加，让每一个高度可以存储更多的索引元素，每个节点又分叉，分出来的叉又有很多个节点。那么存储同等数量级别的数据，横向存储的越多，树高就越小了。这样的一个改造结果就是B-Tree。



#### Hash做数据库索引的问题：
1. 不支持范围查找。

#### B-树做索引的问题：
1. 中间节点的有数据，导致一个节点的size变大，IO费劲，不能用有限的空间分更多的叉


注意，一次load节点是一次磁盘IO，是非常慢的，但是我们把它load到内存中之后在你内存里随机的找某一个元素是非常快的，跟一次磁盘IO这个时间消耗去比对的话几乎可以忽略不计

那按这种说法树的高度越小越好，那按这种思路`可不可以把一个表的数据都放到一个大的节点上`？然后把这个节点一次性load到内存里，我再在内存里一个个去比对不行吗？不是说内存里去比较查找元素是非常的快嘛，跟一次磁盘IO去比对快的多。不可以这样吗？

答案是否定的。

凡事都有个度。你想想，假如我们有几千万数据，在磁盘上面全部放到一个节点上去是不可能的，你的数据表是一行行插入的，存在磁盘上面几百兆甚至几个G，一次性load到内存中合适吗？内存本来就有限，一次性load这么大的数据，而且如果你学过计算机组成原理你也知道，`磁盘IO跟内存打交道的单位是4K`，`一次可能读取4K的数据`，  `可能有时候有一些局部读取的原理可能会取几十K（4的整数倍）`，取个16K，24K也是可以的 。但是一次交互取这么大是搞不定的，这是计算机组成原理定的，一次磁盘IO取那么多数据，对内存也是非常的浪费，而且这一次磁盘IO也是非常慢的。所以这个节点的大小设置要合适，不能太大也不能太小，mysql对这个节点大小设置的是`16K`，用下面这个SQL就是可以查到 show clobal status like 'Innodb_page_size' 。

#### mysql把索引做成b+树的原因：
1. 中间节点不需要放实际数据,只存索引（造成冗余），那么就意味着可以有更多分叉。
   1. 从磁盘中load一个节点，是一次IO操作，IO操作很费时间，且根据计算机组成原理，一次IO交互，一般只能传输4kb的数据（可能有时候有一些局部读取的原理可能会取几十K（4的整数倍），取个16K，24K也是可以的）。但不可能是mb或gb级别的。mysql对这个节点大小设置的是16K
   2. 假设索引字段类型是Bigint，8bit，每两个元素之间存的是下一个节点的地址，mysql分配的是6bit，也就是说一个索引后面配对一个节点地址，成对出现，可以算一下**16K的节点**可以存多少对也就是多少个索引，8b+6b=14b，`16K /14b`=`1170`个索引，叶子节点有索引有data元素，假设占1K，那一个节点就放16K/1K=**16个元素**，假设树高是**3**，所有节点都放满，能放多少数据？可以算一下，1170 * 1170 * 16=21902400，**2千多万**，mysql设置16K的大小，数据就可以存2千多万就已经足够了吧，既能保证一次磁盘IO不要Load太多的数据 又能保证一次load的性能，即便表的数据在几千万的数量也能保证树的高度在一个可控的范围。
   
2. 叶子节点之间还有指针，方便范围查找。
